(* generated by Ott 0.32 from: ../ott/spec.ott *)
(* to compile: Holmake compSpecTheory.uo   *)
(* for interactive use:
  app load ["pred_setTheory","finite_mapTheory","stringTheory","containerTheory","ottLib"];
*)

open HolKernel boolLib Parse bossLib ottLib;
infix THEN THENC |-> ## ;
local open arithmeticTheory stringTheory containerTheory pred_setTheory listTheory 
  finite_mapTheory in end;

val _ = new_theory "compSpec";


val _ = type_abbrev("cn", ``:string``); (* component constant name *)
val _ = type_abbrev("Sn", ``:string``); (* component specification name *)
val _ = type_abbrev("q", ``:string``); (* component variable *)
val _ = type_abbrev("V", ``:string``); (* specification variable *)
val _ = Hol_datatype ` 
c =  (* component term *)
   c_const of cn (* constant *)
 | c_comp of c => c (* composition *)
 | c_var of q (* variable *)
`;
val _ = Hol_datatype ` 
S =  (* specification term *)
   S_const of Sn (* constant *)
 | S_conj of S => S (* conjunction *)
 | S_assume of S => S (* assume-guarantee *)
 | S_par of S => S (* parallel *)
 | S_var of V (* variable *)
 | S_compat (* compatibility *)
 | S_top (* top *)
`;
val _ = Hol_datatype ` 
P =  (* component specification predicate *)
   P_implements of c => S (* implements *)
 | P_refines of S => S (* refines *)
 | P_asserts of S (* assertional *)
 | P_forall_c of q => P (* for all components *)
 | P_exists_c of q => P (* exists component *)
 | P_forall_S of V => P (* for all specifications *)
 | P_exists_S of V => P (* exists specification *)
 | P_implies of P => P (* implies *)
 | P_and of P => P (* conjunction *)
 | P_c_eq of c => c (* component equals *)
 | P_S_eq of S => S (* specification equals *)
`;
val _ = type_abbrev("G", ``:(P set)``);
Definition fv_c:
 (fv_c (c_const cn) = {})
 /\
 (fv_c (c_comp c1 c2) =
  (fv_c c1 UNION fv_c c2))
 /\
 (fv_c (c_var x) = {x})
End

Definition fv_S:
 (fv_S (S_const Sn) = {})
 /\
 (fv_S (S_conj S1 S2) =
  (fv_S S1 UNION fv_S S2))
 /\
 (fv_S (S_assume S1 S2) =
  (fv_S S1 UNION fv_S S2))
 /\
 (fv_S (S_par S1 S2) =
  (fv_S S1 UNION fv_S S2))
 /\
 (fv_S (S_var x) = {x})
 /\
 (fv_S S_compat = {})
 /\
 (fv_S S_top = {})
End

Definition fv_P_c:
 (fv_P_c (P_implements c S) = fv_c c)
 /\
 (fv_P_c (P_refines S1 S2) = {})
 /\
 (fv_P_c (P_asserts S) = {})
 /\
 (fv_P_c (P_forall_c x P) = fv_P_c P DIFF {x})
 /\
 (fv_P_c (P_forall_S x P) = fv_P_c P)
 /\
 (fv_P_c (P_exists_c x P) = fv_P_c P DIFF {x})
 /\
 (fv_P_c (P_exists_S x P) = fv_P_c P)
 /\
 (fv_P_c (P_implies P1 P2) = fv_P_c P1 UNION fv_P_c P2)
 /\
 (fv_P_c (P_and P1 P2) = fv_P_c P1 UNION fv_P_c P2)
 /\
 (fv_P_c (P_c_eq c1 c2) = fv_c c1 UNION fv_c c2)
 /\
 (fv_P_c (P_S_eq S1 S2) = {})
End

Definition fv_P_S:
 (fv_P_S (P_implements c S) = fv_S S)
 /\
 (fv_P_S (P_refines S1 S2) = fv_S S1 UNION fv_S S2)
 /\
 (fv_P_S (P_asserts S) = fv_S S)
 /\
 (fv_P_S (P_forall_c x P) = fv_P_S P)
 /\
 (fv_P_S (P_forall_S x P) = fv_P_S P DIFF {x})
 /\
 (fv_P_S (P_exists_c x P) = fv_P_S P)
 /\
 (fv_P_S (P_exists_S x P) = fv_P_S P DIFF {x})
 /\
 (fv_P_S (P_implies P1 P2) = fv_P_S P1 UNION fv_P_S P2)
 /\
 (fv_P_S (P_and P1 P2) = fv_P_S P1 UNION fv_P_S P2)
 /\
 (fv_P_S (P_c_eq c1 c2) = {})
 /\
 (fv_P_S (P_S_eq S1 S2) = fv_S S1 UNION fv_S S2)
End

(** definitions *)
(* defns spec_proof *)

val (spec_proof_rules, spec_proof_ind, spec_proof_cases) = Hol_reln`
(* defn spec_holds *)

( (* spec_ax *) ! (G:G) (P:P) . (clause_name "spec_ax") ==> 
( ( spec_holds  ( P  INSERT  G )  P )))

/\ ( (* spec_re *) ! (G:G) (c:c) (S2:S) (S1:S) . (clause_name "spec_re") /\
(( ( spec_holds G (P_implements c S1) )) /\
( ( spec_holds G (P_refines S1 S2) )))
 ==> 
( ( spec_holds G (P_implements c S2) )))

/\ ( (* spec_am *) ! (G:G) (c1:c) (c2:c) (S:S) . (clause_name "spec_am") /\
(( ( spec_holds G (P_asserts S) )) /\
( ( spec_holds G (P_implements c1 S) )))
 ==> 
( ( spec_holds G (P_implements (c_comp c1 c2) S) )))

/\ ( (* spec_conji *) ! (G:G) (c:c) (S1:S) (S2:S) . (clause_name "spec_conji") /\
(( ( spec_holds G (P_implements c S1) )) /\
( ( spec_holds G (P_implements c S2) )))
 ==> 
( ( spec_holds G (P_implements c (S_conj S1 S2)) )))

/\ ( (* spec_conje1 *) ! (G:G) (c:c) (S1:S) (S2:S) . (clause_name "spec_conje1") /\
(( ( spec_holds G (P_implements c (S_conj S1 S2)) )))
 ==> 
( ( spec_holds G (P_implements c S1) )))

/\ ( (* spec_conje2 *) ! (G:G) (c:c) (S2:S) (S1:S) . (clause_name "spec_conje2") /\
(( ( spec_holds G (P_implements c (S_conj S1 S2)) )))
 ==> 
( ( spec_holds G (P_implements c S2) )))

/\ ( (* spec_ce *) ! (G:G) (c1:c) (c2:c) (S2:S) (S1:S) . (clause_name "spec_ce") /\
(( ( spec_holds G (P_implements c1 S1) )) /\
( ( spec_holds G (P_implements c2 (S_assume S1 S2)) )))
 ==> 
( ( spec_holds G (P_implements (c_comp c1 c2) S2) )))

/\ ( (* spec_ci *) ! (G:G) (c:c) (S1:S) (S2:S) (q:q) . (clause_name "spec_ci") /\
(( ( q  NOTIN fv_c  c ) ) /\
( ( spec_holds G (P_forall_c q (P_implies (P_implements (c_var q) S1) (P_implements (c_comp (c_var q) c) S2))) )))
 ==> 
( ( spec_holds G (P_implements c (S_assume S1 S2)) )))

/\ ( (* spec_cre *) ! (G:G) (c:c) (S2:S) (S3:S) (S1:S) . (clause_name "spec_cre") /\
(( ( spec_holds G (P_implements c (S_conj S1 S2)) )) /\
( ( spec_holds G (P_refines S2 S3) )))
 ==> 
( ( spec_holds G (P_implements c (S_conj S2 S3)) )))

`;

val _ = export_theory ();



